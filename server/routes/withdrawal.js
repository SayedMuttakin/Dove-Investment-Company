import express from 'express';
import { authMiddleware } from '../middleware/auth.js';
import { adminMiddleware } from '../middleware/admin.js';
import Withdrawal from '../models/Withdrawal.js';
import User from '../models/User.js';
import Deposit from '../models/Deposit.js';
import AdminLog from '../models/AdminLog.js';
import { createNotification } from '../utils/notifications.js';
import { sendWithdrawalRequestEmail, sendWithdrawalApprovedEmail } from '../services/emailService.js';

const router = express.Router();

// Create withdrawal request
router.post('/request', authMiddleware, async (req, res) => {
    try {
        const { amount, bankDetails, paymentMethod } = req.body;
        const userId = req.userId;

        // Get user
        const user = await User.findById(userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        // Check if user is blocked from withdrawing
        if (user.withdrawalBlockMessage) {
            return res.status(403).json({
                message: user.withdrawalBlockMessage,
                isBlocked: true
            });
        }

        // Auto-process matured investments before withdrawal
        const now = new Date();
        let maturedAmount = 0;
        let maturedCount = 0;

        user.investments.forEach(inv => {
            if (inv.status === 'active' && new Date(inv.endDate) <= now) {
                // Investment has matured/completed
                inv.status = 'completed';
                // Return principal amount to balance
                user.balance += inv.package.investmentAmount;
                maturedAmount += inv.package.investmentAmount;
                maturedCount++;

                console.log(`[Withdrawal] Auto-matured investment: ${inv.package.name} - Principal: ${inv.package.investmentAmount} USDT`);
            }
        });

        // Save if any investments were matured
        if (maturedCount > 0) {
            await user.save();
            console.log(`[Withdrawal] ${maturedCount} investments matured. Total returned: ${maturedAmount} USDT. New balance: ${user.balance}`);
        }

        // Validate amount
        if (!amount || amount < 10) {
            return res.status(400).json({ message: 'Minimum withdrawal amount is $10' });
        }

        // Calculate 5% fee and total deduction
        const fee = amount * 0.05;
        const totalAmount = amount + fee;

        // Check if user has sufficient balance for total deduction
        if (user.balance < totalAmount) {
            return res.status(400).json({
                message: 'Insufficient balance (including 5% processing fee)',
                requiredBalance: totalAmount,
                currentBalance: user.balance
            });
        }

        // Validate bank details
        if (!bankDetails || !bankDetails.accountName || !bankDetails.accountNumber || !bankDetails.bankName) {
            return res.status(400).json({ message: 'Please provide complete bank details' });
        }

        // Create withdrawal request
        const withdrawal = new Withdrawal({
            userId,
            amount,
            fee,
            totalAmount,
            bankDetails,
            paymentMethod: paymentMethod || 'bank',
            status: 'pending'
        });

        await withdrawal.save();

        // Deduct from user balance immediately
        user.balance -= totalAmount;
        await user.save();

        // Notification: Withdrawal Requested
        await createNotification({
            userId,
            title: 'Withdrawal Requested',
            message: `Your withdrawal request for $${amount} (plus $${fee} fee, total $${totalAmount}) has been submitted. $${totalAmount} has been deducted from your balance.`,
            type: 'withdrawal',
            amount,
            relatedId: withdrawal._id
        });

        // Send email notification
        if (user.email) {
            await sendWithdrawalRequestEmail(user, withdrawal);
        }

        res.status(201).json({
            message: 'Withdrawal request submitted successfully. Balance deducted.',
            withdrawal,
            newBalance: user.balance
        });

    } catch (error) {
        console.error('Withdrawal request error:', error);
        res.status(500).json({ message: 'Server error' });
    }
});

// Get user's withdrawal history
router.get('/history', authMiddleware, async (req, res) => {
    try {
        const userId = req.user._id;

        const withdrawals = await Withdrawal.find({ userId })
            .sort({ createdAt: -1 })
            .limit(50);

        res.json(withdrawals);
    } catch (error) {
        console.error('Withdrawal history error:', error);
        res.status(500).json({ message: 'Server error' });
    }
});

// Get single withdrawal details
router.get('/:id', authMiddleware, async (req, res) => {
    try {
        const withdrawal = await Withdrawal.findOne({
            _id: req.params.id,
            userId: req.userId
        });

        if (!withdrawal) {
            return res.status(404).json({ message: 'Withdrawal not found' });
        }

        res.json(withdrawal);
    } catch (error) {
        console.error('Withdrawal details error:', error);
        res.status(500).json({ message: 'Server error' });
    }
});

// Admin: Get all withdrawals (with filters)
router.get('/admin/all', authMiddleware, adminMiddleware, async (req, res) => {
    try {
        const { status, limit = 100 } = req.query;
        console.log(`[Admin] Fetching all withdrawals (Status: ${status || 'all'}, Limit: ${limit})...`);
        const query = status ? { status } : {};

        const withdrawals = await Withdrawal.find(query)
            .populate('userId', 'phone fullName invitationCode balance')
            .populate('processedBy', 'phone')
            .sort({ createdAt: -1 })
            .limit(parseInt(limit));

        // Get total deposits for each user
        const userIds = [...new Set(withdrawals.map(w => w.userId?._id))].filter(id => id);
        const invCodes = [...new Set(withdrawals.map(w => w.userId?.invitationCode))].filter(c => c);

        const deposits = await Deposit.aggregate([
            { $match: { userId: { $in: userIds }, status: 'approved' } },
            { $group: { _id: '$userId', total: { $sum: '$amount' } } }
        ]);

        // Aggregate active referrals (users who have invested)
        const activeReferrals = await User.aggregate([
            {
                $match: {
                    referredBy: { $in: invCodes },
                    'investments.0': { $exists: true } // Has at least one investment
                }
            },
            { $group: { _id: '$referredBy', count: { $sum: 1 } } }
        ]);

        // Aggregate total approved withdrawals for each user
        const totalWithdrawals = await Withdrawal.aggregate([
            { $match: { userId: { $in: userIds }, status: 'approved' } },
            { $group: { _id: '$userId', total: { $sum: '$amount' } } }
        ]);

        const depositMap = deposits.reduce((acc, curr) => {
            acc[curr._id.toString()] = curr.total;
            return acc;
        }, {});

        const withdrawalMap = totalWithdrawals.reduce((acc, curr) => {
            acc[curr._id.toString()] = curr.total;
            return acc;
        }, {});

        const referralMap = activeReferrals.reduce((acc, curr) => {
            acc[curr._id] = curr.count;
            return acc;
        }, {});

        const withdrawalsWithDeposits = withdrawals.map(w => {
            const withdrawalObj = w.toObject();
            if (withdrawalObj.userId) {
                withdrawalObj.totalDeposits = depositMap[withdrawalObj.userId._id.toString()] || 0;
                withdrawalObj.totalWithdrawals = withdrawalMap[withdrawalObj.userId._id.toString()] || 0;
                withdrawalObj.activeReferrals = referralMap[withdrawalObj.userId.invitationCode] || 0;
            }
            return withdrawalObj;
        });

        res.json(withdrawalsWithDeposits);
    } catch (error) {
        console.error('Admin withdrawals error:', error);
        res.status(500).json({ message: 'Server error' });
    }
});

// Admin: Approve withdrawal
router.post('/admin/:id/approve', authMiddleware, adminMiddleware, async (req, res) => {
    try {
        const { transactionId, adminNote } = req.body;
        const withdrawalId = req.params.id;
        const adminId = req.userId;

        // Validate transaction ID is provided
        if (!transactionId || transactionId.trim().length === 0) {
            return res.status(400).json({ message: 'Transaction ID is required' });
        }

        const withdrawal = await Withdrawal.findById(withdrawalId);
        if (!withdrawal) {
            return res.status(404).json({ message: 'Withdrawal not found' });
        }

        if (withdrawal.status !== 'pending') {
            return res.status(400).json({ message: 'Withdrawal already processed' });
        }

        // Get user for logging and info
        const user = await User.findById(withdrawal.userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        // Update withdrawal
        withdrawal.status = 'approved';
        withdrawal.transactionId = transactionId.trim();
        withdrawal.processedBy = adminId;
        withdrawal.processedAt = new Date();
        withdrawal.adminNote = adminNote;
        await withdrawal.save();

        // Calculate amounts for notification
        const netAmount = withdrawal.amount;
        const feeAmount = withdrawal.fee || 0;
        const feePercentage = withdrawal.amount > 0 ? ((feeAmount / withdrawal.amount) * 100).toFixed(0) : 5;

        // Notification: Withdrawal Approved with detailed transaction info
        await createNotification({
            userId: user._id,
            title: 'Withdrawal Approved ✓',
            message: `Your withdrawal has been processed successfully! Transaction ID: ${withdrawal.transactionId}. Amount: $${netAmount}, Fee: $${feeAmount} (${feePercentage}%). Click to view details.`,
            type: 'withdrawal',
            amount: withdrawal.amount,
            relatedId: withdrawal._id
        });

        // Send email notification
        if (user.email) {
            await sendWithdrawalApprovedEmail(user, withdrawal);
        }

        // Log admin action
        const log = new AdminLog({
            adminId,
            action: 'withdrawal_approved',
            targetUserId: user._id,
            targetResource: {
                resourceType: 'withdrawal',
                resourceId: withdrawal._id
            },
            changes: {
                amount: withdrawal.amount,
                transactionId: withdrawal.transactionId,
                finalBalance: user.balance
            },
            description: `Approved withdrawal of $${withdrawal.amount} for user ${user.phone}`
        });
        await log.save();

        res.json({
            message: 'Withdrawal approved successfully',
            withdrawal,
            userBalance: user.balance
        });

    } catch (error) {
        console.error('Approve withdrawal error:', error);
        res.status(500).json({ message: 'Server error' });
    }
});

// Admin: Reject withdrawal
router.post('/admin/:id/reject', authMiddleware, adminMiddleware, async (req, res) => {
    try {
        const { rejectionReason, adminNote, blockMessage } = req.body;
        const withdrawalId = req.params.id;
        const adminId = req.userId;

        const withdrawal = await Withdrawal.findById(withdrawalId);
        if (!withdrawal) {
            return res.status(404).json({ message: 'Withdrawal not found' });
        }

        if (withdrawal.status !== 'pending') {
            return res.status(400).json({ message: 'Withdrawal already processed' });
        }

        const user = await User.findById(withdrawal.userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        // Refund user balance
        const refundAmount = withdrawal.totalAmount || (withdrawal.amount + (withdrawal.fee || 0));
        user.balance += refundAmount;

        // Apply block message if provided
        if (blockMessage) {
            user.withdrawalBlockMessage = blockMessage;
        }

        await user.save();

        // Update withdrawal
        withdrawal.status = 'rejected';
        withdrawal.rejectionReason = rejectionReason || 'No reason provided';
        withdrawal.processedBy = adminId;
        withdrawal.processedAt = new Date();
        withdrawal.adminNote = adminNote;
        await withdrawal.save();

        // Notification: Withdrawal Rejected & Refunded
        await createNotification({
            userId: withdrawal.userId,
            title: 'Withdrawal Rejected ✗',
            message: `Your withdrawal of $${withdrawal.amount} has been rejected. $${refundAmount} has been refunded to your balance. Reason: ${withdrawal.rejectionReason}`,
            type: 'withdrawal',
            amount: withdrawal.amount,
            relatedId: withdrawal._id
        });

        // Log admin action
        const log = new AdminLog({
            adminId,
            action: 'withdrawal_rejected',
            targetUserId: withdrawal.userId,
            targetResource: {
                resourceType: 'withdrawal',
                resourceId: withdrawal._id
            },
            changes: {
                amount: withdrawal.amount,
                refunded: refundAmount,
                rejectionReason: withdrawal.rejectionReason,
                newBalance: user.balance
            },
            description: `Rejected withdrawal & refunded $${refundAmount} to user ${user?.phone || 'Unknown'}: ${rejectionReason}`
        });
        await log.save();

        res.json({
            message: 'Withdrawal rejected and balance refunded',
            withdrawal,
            newBalance: user.balance
        });

    } catch (error) {
        console.error('Reject withdrawal error:', error);
        res.status(500).json({ message: 'Server error' });
    }
});

// Admin: Unblock user withdrawal
router.post('/admin/user/:userId/unblock', authMiddleware, adminMiddleware, async (req, res) => {
    try {
        const { userId } = req.params;
        const user = await User.findById(userId);

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        user.withdrawalBlockMessage = null;
        await user.save();

        res.json({ message: 'User withdrawal block removed successfully', user });
    } catch (error) {
        console.error('Unblock user error:', error);
        res.status(500).json({ message: 'Server error' });
    }
});


export default router;
